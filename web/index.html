<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RESQUE</title>
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <div id="main">
        <div class="tabs-sidebar">
            <div class="sidebar-top">
                <div class="top">
                    <h3>RESQUE</h3>
                    <div id="actions">
                        <button onclick="showClearModal()">Clear</button>
                        <button onclick="triggerLoad()">Load</button>
                        <button onclick="exp()">Export</button>
                    </div>
                </div>
                <p id="slot-info"></p>
            </div>
            <div class="tabs-container">
                <div id="tabs">

                </div>
            </div>
            <div id="add-container">
                <div class="doi-input">
                    <button onclick="document.getElementById('add-pdf').click()">Extract DOI from PDF</button>
                    <input id="add-doi" type="text" placeholder="DOI (optional)" />
                </div>

                <div>
                    <b>Add</b>
                    <button onclick="newTab('pub')">Publication</button>
                    <button onclick="newTab('software')">Software</button>
                    <button onclick="newTab('data')">Data Set</button>
                </div>
            </div>
        </div>
        <div id="formview-container">
            <div id="saving" class="animate pop" style="display: none;"></div>
            <div id="formview"></div>
        </div>
        <div id="menu">
            <div class="card animate pop" id="score-box">
                <div class="top">
                    <h3>Score</h3>
                </div>
                <div id="score-container">
                    <p id="score-percentage"></p>
                    <p id="score-dot">‚Ä¢</p>
                    <p id="score-minmax"></p>
                </div>
                <p id="warning-score-too-low">‚ö†Ô∏è Many indicators are not applicable. Manual processing of this
                    publication is recommended.</p>
                <p id="no-score">No score - applicant requests manual processing</p>
            </div>
            <div id="info-box" class="card">
                <p id="item-info">Click on an indicator to see detailed information</p>
                <details id="item-background-details">
                    <summary>Background information</summary>
                    <span id="item-background"></span>
                </details>
            </div>
            <div class="menu-bottom">
                <span onclick="showInfoModal()" class="fakelink">What is RESQUE? / Help / Privacy</span> ‚Ä¢ <a
                    class="github-link" href="https://github.com/nicebread/RESQUE">GitHub</a>
            </div>
        </div>
    </div>
    </div>
    <div id="info-modal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <button onclick="closeInfoModal()" id="add-modal-continue">Continue</button>

            <h2>üëãüèª Welcome to the RESQUE tool!</h2>
            <p>We need to change the way we assess research - with a focus on quality (over quantity). The <a
                    href="https://github.com/nicebread/RESQUE">RESearch QUality Evaluation (RESQUE)</a> framework
                provides an evaluation scheme for publications, data sets, and research software. With this tool, you
                can enter the necessary information for your best research outputs, export a profile that shows your
                research style, and use it for your CV or in hiring and tenure committees.</p>
            <hr>
            <h3>üëÄ How to use the RESQUE tool?</h3>
            <details>
                <summary>How do I add a new publication / software project / data set?</summary>
                Normally, you would use the buttons in the sidebar on the left.
                <br>
                For this time, you can do it here:
                <br><br>
                <button onclick="newTab('pub')">New Publication</button>
                <button onclick="newTab('software')">New Software Project</button>
                <button onclick="newTab('data')">New Data Set</button>
            </details>
            <details>
                <summary>How do I export my data?</summary>
                Clicking on the <button onclick="exp()">Export</button> button here or in the top left corner of this
                website exports a <code>.json</code> file. You can save this on your computer and share it with others.
            </details>
            <details>
                <summary>How do I load data I previously exported?</summary>
                You can use the <button onclick="triggerLoad()">Load</button> button here or in the top left corner of
                this website.
            </details>
            <details>
                <summary>How can I clear all information I entered?</summary>
                You can delete all data stored in the browser by clicking on the <button
                    onclick="showClearModal()">Clear</button> button here or in the top left corner of this website.
            </details>
            <details>
                <summary>What should I do if I want to use RESQUE on a shared/public computer?</summary>
                Whenever you open this website, it loads the locally stored data. On public computers, make sure that
                you clear your data after you exported them.
            </details>
            <hr>
            <h3>üîí Privacy ‚Ä¢ <span class="sub">Is my data stored privately in a safe location?</span></h3>
            <p>
                <b>Nothing leaves your device.</b>
                <br>
                We use the <a href="https://www.wikiwand.com/en/Web_storage">Web Storage API</a> supported by all major
                browsers. Although the website itself is hosted on a server, your data is <i>only</i> stored and
                processed in the local browser:
                <br><br>
                The data is processed only locally. Your score is calculated in the browser. The local PDF files you
                open on this website are <i>not</i> uploaded to a server.
                <br><br>
                This software is 100% free of trackers.
            </p>
        </div>

    </div>
    <dialog id="clear-modal">
        <h3>‚ö†Ô∏è Warning!</h3>
        <p><b>This will delete all of your local data.</b><br><br>Do you want to export the data to a file first?</p><br>
        <button onclick="closeClearModal()">Cancel</button> <button onclick="exp()">Export data to local file</button> <button onclick="reset()" class="critical">Clear all data</button>
    </dialog>
    <input id="fileInput" type="file" accept="text/json" style="visibility: hidden" onchange="handleLoad(this.files)" />
    <a id="download" style="visibility: hidden"></a>
    <input id="add-pdf" type="file" accept="application/pdf" onchange="handleSelectPDF(this.files)"
        style="visibility: hidden;" />


    <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            'https://mozilla.github.io/pdf.js/build/pdf.worker.js';

        function extractText(pdf) {
            var totalPageCount = pdf.numPages;
            var countPromises = [];
            for (
                var currentPage = 1;
                currentPage <= totalPageCount;
                currentPage++
            ) {
                var page = pdf.getPage(currentPage);
                countPromises.push(
                    page.then(function (page) {
                        var textContent = page.getTextContent();
                        return textContent.then(function (text) {
                            return text.items
                                .map(function (s) {
                                    return s.str;
                                })
                                .join(' ');
                        });
                    }),
                );
            }

            return Promise.all(countPromises).then(function (texts) {
                return texts.join(' ');
            })
        }

        function handleSelectPDF(files) {
            var file = files[0];

            //Step 2: Read the file using file reader
            var fileReader = new FileReader();

            fileReader.onload = function () {

                //Step 4:turn array buffer into typed array
                var typedarray = new Uint8Array(this.result);

                //Step 5:pdfjs should be able to read this
                const loadingTask = pdfjsLib.getDocument(typedarray);
                loadingTask.promise.then(pdf => {
                    extractText(pdf).then(text => {
                        let dois = extractDOIs(text);
                        document.getElementById('add-doi').value = dois[0];

                        if (mode === MODE_PREVIEW) {
                            console.log(text);
                            console.log(dois);
                        }
                    })
                });
            };
            //Step 3:Read the file as ArrayBuffer
            fileReader.readAsArrayBuffer(file);
        }

        function extractDOIs(text) {
            let pattern = /\b10\.\d{4,9}\/[-._;()/:a-zA-Z0-9]+\b/g;
            const dois = text.match(pattern);

            return [...new Set(dois)];
        }
    </script>

    <script>


        async function use(...packs) {

            const pool = [];

            const ps = await Promise.all(packs.map(async pack => {
                const response = await fetch("../packs/" + pack + ".json");
                return response.json();
            }));

            ps.forEach(p => pool.push(...p.elements));

            let versions = {};

            ps.forEach(pack => versions[pack.prefix] = pack.version);

            let scoringInfos = {}

            ps.forEach(pack => scoringInfos = { ...scoringInfos, ...pack.scoring })

            return {
                title: ps[0].title,
                versions,
                scoring: scoringInfos,
                pool
            };
        }

        function pick(combinedPack, ...ids) {
            return {
                title: combinedPack.title,
                versions: combinedPack.versions,
                scoring: combinedPack.scoring,
                elements: ids.length <= 0 ? combinedPack.pool : ids.map(id => combinedPack.pool.find(item => item.id === id))
            };
        }

        function pickByPrefix(combinedPack, prefix) {
            return {
                title: combinedPack.title,
                versions: combinedPack.versions,
                scoring: combinedPack.scoring,
                elements: combinedPack.pool.filter(item => item.id.startsWith(prefix))
            };
        }

        function pickByCondition(combinedPack, condition) {
            return {
                title: combinedPack.title,
                scoring: combinedPack.scoring,
                elements: combinedPack.pool.filter(item => condition(item))
            };
        }

        function pickExclude(combinedPack, ...ids) {
            return pickByCondition(combinedPack, item => !ids.includes(item.id));
        }
    </script>

    <script src="menu.js"></script>

    <script>
        const MODE_PREVIEW = "preview";

        let elems = [];
        let tabs = [];

        let formTypes;

        const getVersion = type => formTypes[type].versions[prefixes[type]];

        const getDefaultValues = type => {
            let defaultValues = {};

            for (element of formTypes[type].elements) {
                if (element.default) {
                    if (element.type !== 'checkbox') {
                        defaultValues[element.id] = element.default;
                    } else {
                        element.default.forEach((optionId) => {
                            defaultValues[element.id + '_' + optionId] = true;
                        })
                    }
                }
            }

            return defaultValues;
        }

        // Modal

        window.onclick = e => {
            if (event.target.classList.contains("modal")) {
                e.target.style.display = "none";
            }
        }

        const showClearModal = () => {
            document.getElementById("clear-modal").showModal();
        }

        const closeClearModal = () => {
            document.getElementById("clear-modal").close();
        }

        const showInfoModal = () => {
            document.getElementById("info-modal").style.display = "block";
        }

        const closeInfoModal = () => {
            document.getElementById("info-modal").style.display = "none";
        }

        const newTab = type => {
            let doiField = document.getElementById("add-doi");
            let doi = doiField.value;

            doiField.value = "";

            let index = results.length

            results.push({
                type,
                version: getVersion(type),
                date_added: Date.now(),
                ...getDefaultValues(type)
            });

            results[0].date_modified = Date.now();

            document.getElementById("tabs").appendChild(createTab(results[results.length - 1], results.length - 1));

            const tabsElement = document.getElementsByClassName("tabs-sidebar")[0];

            if (doi) {
                fetch("https://doi.org/" + doi.trim(), {
                    headers: {
                        Accept: 'application/vnd.citationstyles.csl+json'
                    }
                })
                    .then(response => response.json())
                    .then(response => {
                        if (mode === MODE_PREVIEW) {
                            console.log(response);
                        }

                        if (type === "pub") {
                            results[index].Title = response.title;
                            results[index].Year = response.published["date-parts"][0][0];
                            results[index].DOI = response.DOI;

                            save();

                            if (currentTab === index) {
                                location.reload();
                            } else {
                                // Switch to new tab
                                tabs[results.length - 1].click();

                                tabsElement.scrollTo({
                                    top: tabsElement.scrollHeight,
                                    behavior: "smooth"
                                });
                            }
                        }
                    })
            } else {
                // Switch to new tab
                save();

                tabs[results.length - 1].click();

                tabsElement.scrollTo({
                    top: tabsElement.scrollHeight,
                    behavior: "smooth"
                });
            }
        }

        const save = () => {
            localStorage.setItem("formdata", JSON.stringify(results))
        }

        const getSavedData = () => {
            return JSON.parse(localStorage.getItem("formdata")) || [{ type: "meta", publications: 0, software_projects: 0, data_sets: 0 }];
        }

        const reset = () => {
            results = {};
            localStorage.clear();
            sessionStorage.clear();
            location.reload();
        }

        const triggerLoad = () => {
            fileSelector = document.getElementById("fileInput");
            fileSelector.click();
        }

        const handleLoad = async files => {
            let loadedData = JSON.parse(await files[0].text());

            if (loadedData.every(r => getVersion(r.type) === r.version)) {
                results = loadedData;
                save();
                sessionStorage.clear();
                location.reload();
            } else {
                alert("Error: Could not load data because it was created using an earlier version.");
            }
        }

        const exp = () => {
            let millis = Date.now();
            results[0].date_exported = millis;
            let json = JSON.stringify(results, null, 2);
            let blob = new Blob([json], { type: "text/json;charset=utf-8" });
            let filename = `resque_${results[0].M1 ? results[0].M1.toLowerCase() + "_" : ""}${millis}.json`;

            let a = document.getElementById("download");
            a.innerText = filename;
            a.download = filename;
            a.href = (window.URL || window.webkitURL).createObjectURL(blob);

            a.click();
        }

        const showSaving = () => {
            let saving = document.getElementById("saving");

            if (saving.style.display !== "none") {
                return;
            }

            saving.innerText = "Saving changes...";

            saving.style.display = "block";

            new Promise(r => setTimeout(r, 750))
                .then(() => {
                    saving.innerText = "Done ‚úÖ";
                });

            new Promise(r => setTimeout(r, 1500))
                .then(() => {
                    saving.style.display = "none";
                });
        }

        const update = e => {
            // Save date_created
            if (!results[0].date_created) {
                results[0].date_created = Date.now();

                if (mode === MODE_PREVIEW) {
                    console.log("First change: date_created saved.");
                }
            }

            results[0].date_modified = Date.now();

            let elem = elems.find(elem => elem.id === e.target.id);

            if (e.target.classList.contains("type-radio") || e.target.classList.contains("type-dropdown")) {
                result[e.target.name] = e.target.value;
                elem = elems.find(elem => elem.id === e.target.name);
            } else if (e.target.classList.contains("type-checkbox")) {
                if (e.target.id === "P_TopPaper_Select") {
                    const count = results.filter(r => r.type === "pub" && r["P_TopPaper_Select"] === true).length;

                    if (e.target.checked && count >= maxTopPapers) {
                        e.target.checked = false;
                        alert("You already selected three best papers. Please deselect one of them to select a new one.");
                    }
                }

                result[e.target.id] = e.target.checked;

                elem = elems.find(elem => elem.id === e.target.id.slice(0, e.target.id.lastIndexOf('_')));
            } else if (e.target.classList.contains("type-boolean")) {
                result[e.target.id] = e.target.value === "true";
            } else if (e.target.classList.contains("type-textbox")) {
                result[e.target.id] = e.target.innerText;
            } else {
                result[e.target.id] = e.target.value;
            }

            if (mode === MODE_PREVIEW) {
                console.log(results);
            }

            save();
            updateInfo();
            updateTabs();
            applyFilters();
            rerenderDynamicValues();
            showInfo(e, elem);
            showSaving();
        }

        const rerenderDynamicValues = () => {
            // Update info items with value insertion
            for (elem of elems) {
                // Do not reload if click event (click events are only relevant for the info box)
                if (elem.type === 'info' && /\$[a-zA-Z0-9_]+/.test(elem.text)) {
                    let domElement = document.getElementById(elem.id);
                    domElement.innerHTML = preprocessText(elem.text);

                    if (/\$[a-zA-Z0-9_]+@papers/.test(elem.text)) {
                        const tabWidth = tabs[0].clientWidth;
                        domElement.childNodes.forEach(t => {
                            t.addEventListener('click', handleTabClick);
                            t.setAttribute("style", "width:" + tabWidth);
                        });
                    }
                } else if (/\$[a-zA-Z0-9_]+/.test(elem.title)) {
                    document.querySelector("." + elem.id + ".title").innerHTML = preprocessText(elem.title);
                }
            }
        }

        const updateInfo = () => {
            const usedSlots = results.length - 1;
            const maxReached = usedSlots >= max;

            document.getElementById("slot-info").innerText = `${usedSlots} of ${max} slots used${maxReached ? ", you can't add more publications." : ""}`;

            if (usedSlots >= max) {
                document.getElementById("add-container").style.display = "none"
            } else {
                document.getElementById("add-container").style.display = "inherit"
            }

            let numberOfPublications = 0;
            let numberOfSoftwareProjects = 0;
            let numberOfDataSets = 0;

            tabs.forEach(t => {
                const content = t.firstChild;

                const index = parseInt(t.getAttribute("data-index"));
                const result = results[index];

                switch (result.type) {
                    case "meta":
                        content.innerHTML = `<b>Author / Metadata</b>${result["LastName"] ? '<br>' + result["LastName"] : ''}`;
                        break;
                    case "pub":
                        content.innerHTML = `<b>Publication ${++numberOfPublications}</b>${result["Title"] ? '<br>' + result["Title"] : ''}`
                        break;
                    case "software":
                        content.innerHTML = `<b>Software Project ${++numberOfSoftwareProjects}</b>${result["Title"] ? '<br>' + result["Title"] : ''}`;
                        break;
                    case "data":
                        content.innerHTML = `<b>Data Set ${++numberOfDataSets}</b>${result["Title"] ? '<br>' + result["Title"] : ''}`;
                        break;

                    default:
                        break;
                }
            })

            if (result.type === 'meta') {
                // Hide the score box and skip updating score values
                document.getElementById('score-box').style.display = "none";
                return;
            }

            let scoringResult = score(result);

            if (scoringResult.max < 5 && scoringResult.max > 0) {
                document.getElementById('warning-score-too-low').style.display = 'block';
                document.getElementById('score-box').classList.add('warning');
            } else {
                document.getElementById('warning-score-too-low').style.display = 'none';
                document.getElementById('score-box').classList.remove('warning');
            }

            // Show score box
            document.getElementById('score-box').style.display = "";

            if (scoringResult.max > 0) {
                document.getElementById("no-score").style.display = "none";
                document.getElementById("score-container").style.display = "flex"
                document.getElementById("score-minmax").innerHTML = `${scoringResult.score} / ${scoringResult.max}`
                document.getElementById("score-percentage").innerHTML = `${scoringResult.percentage}%`
            } else {
                document.getElementById("no-score").style.display = "block";
                document.getElementById("score-container").style.display = "none"
            }
        }

        const preprocessCondition = condition => {
            let processedCondition = condition
                .replaceAll(/([\$\w]+)\s*=\|=\s*\[(.*?)\]/g, (match, variable, list) => {
                    return "(" + list.split(",")
                        .map(value => `${variable} === ${value.trim()}`)
                        .join(" || ") + ")";
                })
                .replaceAll(/([\$\w]+)\s*=&=\s*\[(.*?)\]/g, (match, variable, list) => {
                    return "(" + list.split(",")
                        .map(value => `${variable} === ${value.trim()}`)
                        .join(" && ") + ")";
                })

            return processedCondition;
        }

        const insertValuesIntoCondition = condition => {
            return condition.replaceAll(/\$(\w*)/g, `result['$1']`);
        }

        const evaluateCondition = condition => eval(insertValuesIntoCondition(preprocessCondition(condition)));

        const applyFilters = () => {
            if (mode === MODE_PREVIEW) {
                return;
            }

            for (let elem of elems) {
                if (!elem.condition) continue;


                const domElements = [...document.getElementsByClassName(elem.id)];

                if (evaluateCondition(elem.condition)) {
                    domElements.forEach(de => de.style.display = "")
                } else {
                    domElements.forEach(de => de.style.display = "none")
                }
            }
        }

        const countWords = (text) => {
            return text.trim() ? text.replace(/[\r\n\t]+/g, " ").split(/\s+/).filter(x => x).length : 0;
        }

        const updateWordcount = (textbox, wordcount) => {
            const words = countWords(textbox.innerText);

            if (textbox.hasAttribute("data-maxwords")) {
                const maxwords = parseInt(textbox.getAttribute("data-maxwords"));
                wordcount.innerText = words + " / " + maxwords;

                if (words <= maxwords) {
                    wordcount.classList.add("wordcount-ok");
                    wordcount.classList.remove("wordcount-warning");
                } else {
                    wordcount.classList.remove("wordcount-ok");
                    wordcount.classList.add("wordcount-warning");
                }
            } else {
                wordcount.innerText = words;
            }
        }

        const textboxWordcount = e => {
            const wordcount = document.getElementById(e.target.id + "-wordcount");

            updateWordcount(e.target, wordcount);
        }

        const partialHighlight = (indicatorId, text) => {
            return text.replaceAll(/\{(.*?)\|(.*?)\}/g, (match, foundCondition, text) => {
                let condition = foundCondition.trim();

                if (condition.startsWith(':')) {
                    condition = `$${indicatorId} =|= [${condition.replace(':', '')}]`
                }

                return evaluateCondition(condition)
                    ? `<span class="highlight">${text.trim()}</span>`
                    : text
            });
        }

        const showInfo = (e, element) => {
            const itemInfo = document.getElementById("item-info");
            const itemBackground = document.getElementById("item-background");
            const itemBackgroundDetails = document.getElementById("item-background-details");

            if (element.info) {
                itemInfo.style.color = "#333333";
                itemInfo.innerHTML = `<b>${element.id}</b>${element.eval_dimension ? '<span id="eval-dimension">' + element.eval_dimension + '</span>' : ""}<br><br>${partialHighlight(element.id, element.info)}`;
            } else {
                itemInfo.style.color = "gray";
                itemInfo.innerHTML = `<b>${element.id}</b>${element.eval_dimension ? '<span id="eval-dimension">' + element.eval_dimension + '</span>' : ""}<br><br><i>No information</i>`;
            }

            if (element.background) {
                itemBackground.innerHTML = element.background;
                itemBackgroundDetails.style.display = "block";
                itemBackgroundDetails.removeAttribute("open");
            } else {
                itemBackgroundDetails.style.display = "none";
            }
        }

        const insertValuesIntoText = text => {
            const processType = {
                datetime: (value) => {
                    const millis = parseInt(value);
                    return millis ? new Date(millis).toLocaleString() : '...';
                },
                date: (value) => {
                    const millis = parseInt(value);
                    return millis ? new Date(millis).toLocaleDateString() : '...';
                },
                default: (value) => 'Unknown type'
            }

            const globals = {
                paper_count: (value) => results.filter(r => r.type === 'pub' && r[value] === true).length,

                papers: (value) => {
                    let topPapers = results.map((r, index) => {
                        r.position = index;
                        return r;
                    }).filter(r => r.type === 'pub' && r[value] === true);

                    let positions = topPapers.map(paper => paper.position);

                    if (topPapers.length <= 0) {
                        return "<i>No papers selected</i>";
                    }

                    const papersToDisplay = tabs
                        .filter((tab, index) => positions.includes(index))
                        .map(t => {
                            t.classList.remove("selected");
                            return t.outerHTML;
                        });

                    return papersToDisplay.join("");
                }
            }
            return text
                .replaceAll(/global\$([a-zA-Z0-9_]+)@([a-zA-Z0-9_]+)/g, (match, variable, type) => {
                    return globals[type.trim()](variable.trim());
                })
                .replaceAll(/\$([a-zA-Z0-9_]+)@([a-zA-Z0-9_]+)/g, (match, variable, type) => {
                    return processType[type.trim()](result[variable.trim()]);
                })
                .replaceAll(/\$([a-zA-Z0-9_]+)/g, (match, variable) => {
                    return result[variable.trim()];
                });
        }

        const preprocessText = text => insertValuesIntoText(partialHighlight(null, text));

        const createInput = (element) => {
            elems.push(element);

            const creator = {
                "separator": () => {
                    let separator = document.createElement("hr");

                    return separator;
                },
                "info": () => {
                    let info = document.createElement("p");
                    info.id = element.id;

                    info.innerHTML = preprocessText(element.text);

                    return info;
                },
                "text": () => {
                    let input = document.createElement("input");
                    input.type = "text";

                    input.placeholder = element.title || '';

                    return input;
                },
                "textbox": () => {
                    let container = document.createElement("div");
                    container.classList.add("textbox-container");

                    let input = document.createElement("div");
                    input.id = element.id;
                    input.classList.add("textbox", "type-textbox");
                    input.contentEditable = true;

                    let wordcount = document.createElement("div");
                    wordcount.id = element.id + "-wordcount";
                    wordcount.classList.add("wordcount");

                    if (element.id in result) {
                        input.innerText = result[element.id];
                    }

                    if (element.maxwords) {
                        input.setAttribute("data-maxwords", element.maxwords);
                        wordcount.classList.add("wordcount-max");
                    }

                    updateWordcount(input, wordcount);

                    input.addEventListener("input", textboxWordcount);
                    input.addEventListener("blur", update);

                    container.append(input, wordcount);

                    return container;
                },
                "number": () => {
                    let input = document.createElement("input");
                    input.type = "number";

                    input.placeholder = element.title || '';

                    return input;
                },
                "date": () => {
                    let input = document.createElement("input");
                    input.type = "date";

                    input.placeholder = element.title || '';

                    return input;
                },
                "dropdown": () => {
                    let input = document.createElement("select");
                    input.name = element.id;
                    input.id = element.id;

                    const values = element.values || element.options;

                    let options = element.options.map((option, index) => {
                        let opt = document.createElement("option")
                        opt.value = index;
                        opt.innerText = option;

                        if (mode === MODE_PREVIEW) {
                            opt.innerText = `[${index}] ${option}`;
                        }

                        return opt;
                    })

                    input.append(...options);

                    return input;
                },
                "boolean": () => {
                    let input = document.createElement("select");
                    input.name = element.id;
                    input.id = element.id;

                    let options = element.options.map((option, index) => {
                        let opt = document.createElement("option")
                        opt.value = index == 0;
                        opt.innerText = option;

                        return opt;
                    })

                    input.append(...options);

                    return input;
                },
                "radio": () => {
                    let input = document.createElement("div");
                    input.classList.add("radio", element.alignment ? "alignment-" + element.alignment : "alignment-vertical")

                    let options = element.options.map((option, index) => {
                        let container = document.createElement("div");

                        let label = document.createElement("label");

                        let radio = document.createElement("input");
                        radio.type = "radio";
                        radio.value = option.id;
                        radio.name = element.id;
                        radio.classList.add("type-radio");

                        let optionText = option.text;

                        if (mode === MODE_PREVIEW) {
                            optionText = `[${option.id}] ${optionText}`;
                        }

                        label.append(radio, optionText);

                        if (element.id in result && result[element.id] === option.id) {
                            radio.checked = true;
                        }

                        return label;
                    })

                    input.append(...options);

                    return input;
                },
                "checkbox": () => {
                    let input = document.createElement("div");

                    let options = element.options.map((option, index) => {
                        let container = document.createElement("div");

                        let label = document.createElement("label");

                        let checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.id = element.id + '_' + (option.id ? option.id : String.fromCharCode(index + 97));
                        checkbox.classList.add("type-checkbox");

                        let text = typeof option === 'string' ? option : option.text;

                        if (mode === MODE_PREVIEW) {
                            text = `[${checkbox.id}] ${option}`;
                        }

                        label.append(checkbox, text);

                        // Last option exclusive
                        if (element.last_option_exclusive) {
                            // Uncheck others if the last one is checked
                            if (index === element.options.length - 1) {
                                checkbox.addEventListener("change", e => {
                                    if (e.target.checked) {
                                        element.options.forEach((option, index) => {
                                            if (index !== element.options.length - 1) {
                                                let id = element.id + String.fromCharCode(index + 97);
                                                document.getElementById(id).checked = false;
                                                update({ ...e, target: document.getElementById(id) })
                                            }
                                        })
                                    }
                                })
                            } else {
                                // Uncheck last one if one of the others is checked
                                checkbox.addEventListener("change", e => {
                                    let id = element.id + String.fromCharCode(options.length - 1 + 97);

                                    if (e.target.checked) {
                                        document.getElementById(id).checked = false;
                                    }

                                    update({ ...e, target: document.getElementById(id) });
                                })
                            }
                        }

                        if (checkbox.id in result && result[checkbox.id] === true) {
                            checkbox.checked = true;
                        }

                        return label;
                    })

                    input.append(...options);

                    return input;
                },
                "global_checkbox": () => {
                    let container = document.createElement("div");

                    let label = document.createElement("label");

                    let checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.id = element.id;
                    checkbox.classList.add("type-global_checkbox");

                    if (result[element.id]) {
                        checkbox.checked = result[element.id];
                    }

                    label.append(checkbox, element.text);
                    container.appendChild(label);

                    return container;
                }
            }

            if (element.type in creator) {
                let domElement = creator[element.type]();

                domElement.classList.add("type-" + element.type);

                if (element.id) {
                    domElement.id = element.id;
                }

                domElement.pattern = element.check;


                if (filterTriggers.includes(element.id)) {
                    domElement.addEventListener('input', update);
                }


                if (element.id in result) {
                    domElement.value = result[element.id];
                }

                let fragment = document.createElement("div");

                if (element.title) {
                    let title = document.createElement("p");
                    title.innerText = preprocessText(element.title);

                    title.classList.add(element.id, "title");
                    fragment.appendChild(title);

                    if (mode === MODE_PREVIEW) {
                        title.innerText = `[${element.id}] ${title.innerText}`;
                    }
                }


                domElement.classList.add(element.id);

                if (mode === MODE_PREVIEW && element.condition) {
                    let previewCondition = document.createElement("p");
                    previewCondition.innerHTML = `[ <i>Condition:</i>  <code>${element.condition}</code> ]`;
                    fragment.appendChild(previewCondition);
                }

                fragment.appendChild(domElement);

                fragment.title = element.tooltip || "";
                fragment.addEventListener("click", e => showInfo(e, element));

                return fragment;
            } else return "";
        }

        const createForm = (form) => {
            let formElement = document.createElement("form");

            let domElements = form.elements.map(elem => createInput(elem));

            let title = document.createElement("h2");
            title.innerText = form.title;

            if (mode === MODE_PREVIEW) {
                title.innerText = "[Preview] " + title.innerText;
            }

            formElement.append(title, ...domElements);

            formElement.addEventListener('change', update);

            return formElement;
        }

        const handleTabClick = e => {
            currentTab = parseInt(e.target.getAttribute("data-index"));
            sessionStorage.setItem("index", currentTab.toString())

            if (currentTab !== preTab) {
                loadForm({ index: currentTab });
                preTab = currentTab;
            }

            updateTabs();
        }

        const loadForm = options => {
            elems = [];
            result = results[options.index];

            const formView = document.getElementById("formview");
            const scrollPre = formView.scrollTop;

            filterTriggers = formTypes[result.type].elements
                .filter(element => element.condition)
                .map(element => element.condition.match(/\$\w*/g))
                .flat()
                .map(ids => ids.replaceAll('$', ''));

            formView.innerHTML = "";
            formView.appendChild(createForm(formTypes[result.type]));

            if (options.preserveScrollHeight) {
                formView.scrollHeight = scrollPre;
            }

            applyFilters();
            updateInfo();
            rerenderDynamicValues();
        }

        const updateTabs = () => {
            tabs.forEach(t => {
                if (parseInt(t.getAttribute("data-index")) === currentTab) {
                    t.classList.add("selected");
                } else {
                    t.classList.remove("selected");
                }
            })
        }

        const createTab = (result, index) => {
            let tab = document.createElement("div");
            tab.classList.add("tab");

            let content = document.createElement("span");
            tab.appendChild(content);

            tab.setAttribute("data-index", index);

            tab.addEventListener("click", handleTabClick);

            tabs.push(tab);
            return tab;
        }

        const score = r => {
            const scoring = formTypes[r.type].scoring;

            let maxScore = 0;
            let reachedScore = 0;

            for (indicator in scoring) {
                if (scoring[indicator].not_applicable && evaluateCondition(scoring[indicator].not_applicable)) {
                    continue;
                }

                maxScore += scoring[indicator].max;

                switch (scoring[indicator].op) {
                    case "sum":
                        reachedScore += scoring[indicator].points
                            .filter(p => evaluateCondition(p.condition))
                            .reduce((sum, next) => sum + next.value, 0);
                        break;
                    case "select":
                        reachedScore += (scoring[indicator].points.find(p => evaluateCondition(p.condition)) || { value: 0 }).value;
                        break;
                    default:
                        break;
                }


            }


            return {
                max: maxScore,
                score: reachedScore,
                relative: reachedScore / maxScore,
                percentage: ((reachedScore / maxScore) * 100).toFixed(1)
            }
        }

        let meta, pub, software, data, max, maxTopPapers;

        let filterTriggers;

        const params = new URLSearchParams(window.location.search);
        const mode = params.get("mode");
        const doimagic = params.get("doimagic");

        let results = getSavedData();

        let currentTab = parseInt(sessionStorage.getItem("index") || "0");
        let preTab = -1;
        let result = results[currentTab];

        let prefixes = {
            meta: "M",
            pub: "P",
            software: "S",
            data: "D"
        }

        if (!localStorage.getItem("formdata")) {
            showInfoModal();
        }

        menu().then(m => {
            formTypes = m;
            ({ meta, pub, software, data, max, maxTopPapers } = m);
            results.forEach((r, index) => {
                document.getElementById("tabs").appendChild(createTab(r, index));
            });

            loadForm({ index: currentTab });
            updateTabs();
            updateInfo();
            applyFilters();
        })
    </script>
</body>

</html>