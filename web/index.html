<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RESQUE</title>
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <div class="topbar">
        <p id="slot-info"></p>
        <div class="tabs-container">
            <div id="tabs">

            </div>
            <button class="add-button" id="add-button" onclick="newTab('pub')">+</button>
        </div>
    </div>

    <div id="main">
        <div id="formview"></div>
        <div id="menu">
            <div class="card">
                <div class="top">
                    <h3>RESQUE</h3>
                    <div id="actions">
                        <button onclick="reset()">Reset</button>
                        <button onclick="triggerLoad()">Load</button>
                        <button onclick="exp()">Export</button>
                    </div>
                </div>
                <div id="score-container">
                    <p id="score-percentage"></p>
                    <p id="score-dot">â€¢</p>
                    <p id="score-minmax"></p>
                </div>
            </div>
            <div class="card">
                <p id="item-info">Click on an item to show detailed information</p>
                <details id="item-background-details">
                    <summary>Background information</summary>
                    <span id="item-background"></span>
                </details>
            </div>
        </div>
    </div>
    </div>
    <input id="fileInput" type="file" accept="text/json" style="visibility: hidden" onchange="handleLoad(this.files)" />
    <a id="download" style="visibility: hidden"></a>
</body>

<script>


    async function use(...packs) {

        const pool = [];

        const ps = await Promise.all(packs.map(async pack => {
            const response = await fetch("../packs/" + pack + ".json");
            return response.json();
        }));

        ps.forEach(p => pool.push(...p.elements));

        let versions = {};

        ps.forEach(pack => versions[pack.prefix] = pack.version);

        let scoringInfos = {}

        ps.forEach(pack => scoringInfos = { ...scoringInfos, ...pack.scoring })

        return {
            title: ps[0].title,
            versions,
            scoring: scoringInfos,
            pool
        };
    }

    function pick(combinedPack, ...ids) {
        return {
            title: combinedPack.title,
            versions: combinedPack.versions,
            scoring: combinedPack.scoring,
            elements: ids.length <= 0 ? combinedPack.pool : ids.map(id => combinedPack.pool.find(item => item.id === id))
        };
    }

    function pickByPrefix(combinedPack, prefix) {
        return {
            title: combinedPack.title,
            versions: combinedPack.versions,
            scoring: combinedPack.scoring,
            elements: combinedPack.pool.filter(item => item.id.startsWith(prefix))
        };
    }

    function pickByCondition(combinedPack, condition) {
        return {
            title: combinedPack.title,
            scoring: combinedPack.scoring,
            elements: combinedPack.pool.filter(item => condition(item))
        };
    }

    function pickExclude(combinedPack, ...ids) {
        return pickByCondition(combinedPack, item => !ids.includes(item.id));
    }
</script>

<script src="menu.js"></script>

<script>
    const MODE_PREVIEW = "preview";

    let elems = [];
    let tabs = [];

    let formTypes;

    const getVersion = type => formTypes[type].versions[prefixes[type]];

    const newTab = type => {
        results.push({ type, version: getVersion(type) });
        document.getElementById("tabs").appendChild(createTab(results[results.length - 1], results.length - 1));

        updateTabs();
        updateInfo();
        save();

        const tabsElement = document.getElementById("tabs");
        tabsElement.scrollTo({
            left: tabsElement.scrollWidth,
            behavior: "smooth"
        });
    }

    const save = () => {
        localStorage.setItem("formdata", JSON.stringify(results))
    }

    const getSavedData = () => {
        return JSON.parse(localStorage.getItem("formdata")) || [{ type: "meta" }];
    }

    const reset = () => {
        results = {};
        localStorage.clear();
        location.reload();
    }

    const triggerLoad = () => {
        fileSelector = document.getElementById("fileInput");
        fileSelector.click();
    }

    const handleLoad = async files => {
        let loadedData = JSON.parse(await files[0].text());

        if (loadedData.every(r => getVersion(r.type) === r.version)) {
            results = loadedData;
            save();
            location.reload();
        } else {
            alert("Error: Could not load data because it was created using an earlier version.");
        }
    }

    const exp = () => {
        let json = JSON.stringify(results, null, 2);
        let blob = new Blob([json], { type: "text/json;charset=utf-8" });
        let filename = 'export.json';

        let a = document.getElementById("download");
        a.innerText = filename;
        a.download = filename;
        a.href = (window.URL || window.webkitURL).createObjectURL(blob);

        a.click();
    }

    const update = e => {

        const formView = document.getElementById("formview");
        const scrollPre = formView.scrollTop;

        if (e.target.classList.contains("type-radio") || e.target.classList.contains("type-dropdown")) {
            result[e.target.name] = parseInt(e.target.value);
        } else if (e.target.classList.contains("type-checkbox")) {
            result[e.target.id] = e.target.checked;
        } else if (e.target.classList.contains("type-boolean")) {
            result[e.target.id] = e.target.value === "true";
        } else if (e.target.classList.contains("type-textbox")) {
            result[e.target.id] = e.target.innerText;
        } else {
            result[e.target.id] = e.target.value;
        }

        if (mode === MODE_PREVIEW) {
            console.log(results);
        }

        save();
        updateInfo();
        updateTabs();
        applyFilters();

        formView.scrollTop = scrollPre;
    }

    const updateInfo = () => {
        const usedSlots = results.length - 1;
        const maxReached = usedSlots >= max;

        document.getElementById("slot-info").innerText = `${usedSlots} of ${max} slots used${maxReached ? ", you can't add more publications." : ""}`;

        if (usedSlots >= max) {
            document.getElementById("add-button").style.display = "none"
        } else {
            document.getElementById("add-button").style.display = "inherit"
        }

        tabs.forEach(t => {
            const content = t.firstChild;

            const index = parseInt(t.getAttribute("data-index"));
            const result = results[index];

            switch (result.type) {
                case "meta":
                    content.innerHTML = `<b>Author</b>`;
                    break;
                case "pub":
                    content.innerHTML = result["P2"] && result["P3"]
                        ? `<b>P${result["P2"]}:</b> ${result["P3"]}`
                        : "<b>New publication<b>";
                    break;
                case "software":
                    content.innerHTML = `<b>New software project</b>`;
                    break;
                case "data":
                    content.innerHTML = `<b>New data</b>`;
                    break;

                default:
                    break;
            }
        })

        let scoringResult = score(result);

        if (scoringResult.max > 0) {
            document.getElementById("score-container").style.display = "flex"
            document.getElementById("score-minmax").innerHTML = `${scoringResult.score}/${scoringResult.max}`
            document.getElementById("score-percentage").innerHTML = `${scoringResult.percentage}%`
        } else {
            document.getElementById("score-container").style.display = "none"
        }
    }

    const preprocessCondition = condition => {
        let processedCondition = condition
            .replaceAll(/([\$\w]+)\s*=\|=\s*\[(.*?)\]/g, (match, variable, list) => {
                return "(" + list.split(",")
                    .map(value => `${variable} === ${value.trim()}`)
                    .join(" || ") + ")";
            })
            .replaceAll(/([\$\w]+)\s*=&=\s*\[(.*?)\]/g, (match, variable, list) => {
                return "(" + list.split(",")
                    .map(value => `${variable} === ${value.trim()}`)
                    .join(" && ") + ")";
            })

        return processedCondition;
    }

    const insertValuesIntoCondition = condition => {
        return condition.replaceAll(/\$(\w*)/g, `result['$1']`);
    }

    const evaluateCondition = condition => eval(insertValuesIntoCondition(preprocessCondition(condition)));

    const applyFilters = () => {
        if (mode === MODE_PREVIEW) {
            return;
        }

        for (let elem of elems) {
            if (!elem.condition) continue;


            const domElements = [...document.getElementsByClassName(elem.id)];

            if (evaluateCondition(elem.condition)) {
                domElements.forEach(de => de.style.display = "")
            } else {
                domElements.forEach(de => de.style.display = "none")
            }
        }
    }

    const countWords = (text) => {
        return text.trim() ? text.replace(/[\r\n\t]+/g, " ").split(/\s+/).filter(x => x).length : 0;
    }

    const updateWordcount = (textbox, wordcount) => {
        const words = countWords(textbox.innerText);

        if (textbox.hasAttribute("data-maxwords")) {
            const maxwords = parseInt(textbox.getAttribute("data-maxwords"));
            wordcount.innerText = words + " / " + maxwords;

            if (words <= maxwords) {
                wordcount.classList.add("wordcount-ok");
                wordcount.classList.remove("wordcount-warning");
            } else {
                wordcount.classList.remove("wordcount-ok");
                wordcount.classList.add("wordcount-warning");
            }
        } else {
            wordcount.innerText = words;
        }
    }

    const textboxWordcount = e => {
        const wordcount = document.getElementById(e.target.id + "-wordcount");

        updateWordcount(e.target, wordcount);
    }

    const showInfo = (e, element) => {
        const itemInfo = document.getElementById("item-info");
        const itemBackground = document.getElementById("item-background");
        const itemBackgroundDetails = document.getElementById("item-background-details");

        if (element.info) {
            itemInfo.style.color = "#333333";
            itemInfo.innerHTML = `<b>${element.id}</b><span id="eval-dimension">${element.eval_dimension ? element.eval_dimension : ""}</span><br><br>${element.info}`;
        } else {
            itemInfo.style.color = "gray";
            itemInfo.innerHTML = `<b>${element.id}</b><span id="eval-dimension">${element.eval_dimension ? element.eval_dimension : ""}</span><br><br><i>No information</i>`;
        }

        if (element.background) {
            itemBackground.innerHTML = element.background;
            itemBackgroundDetails.style.display = "block";
            itemBackgroundDetails.removeAttribute("open");
        } else {
            itemBackgroundDetails.style.display = "none";
        }
    }

    const createInput = (element) => {
        elems.push(element);

        const creator = {
            "separator": () => {
                let separator = document.createElement("hr");

                return separator;
            },
            "info": () => {
                let info = document.createElement("p");
                info.id = element.id;

                info.innerHTML = element.text;

                return info;
            },
            "text": () => {
                let input = document.createElement("input");
                input.type = "text";

                input.placeholder = element.title || '';

                return input;
            },
            "textbox": () => {
                let container = document.createElement("div");
                container.classList.add("textbox-container");

                let input = document.createElement("div");
                input.id = element.id;
                input.classList.add("textbox", "type-textbox");
                input.contentEditable = true;

                let wordcount = document.createElement("div");
                wordcount.id = element.id + "-wordcount";
                wordcount.classList.add("wordcount");

                if (element.id in result) {
                    input.innerText = result[element.id];
                }

                if (element.maxwords) {
                    input.setAttribute("data-maxwords", element.maxwords);
                    wordcount.classList.add("wordcount-max");
                }

                updateWordcount(input, wordcount);

                input.addEventListener("input", textboxWordcount);
                input.addEventListener("blur", update);

                container.append(input, wordcount);

                return container;
            },
            "number": () => {
                let input = document.createElement("input");
                input.type = "number";

                input.placeholder = element.title || '';

                return input;
            },
            "date": () => {
                let input = document.createElement("input");
                input.type = "date";

                input.placeholder = element.title || '';

                return input;
            },
            "dropdown": () => {
                let input = document.createElement("select");
                input.name = element.id;
                input.id = element.id;

                const values = element.values || element.options;

                let options = element.options.map((option, index) => {
                    let opt = document.createElement("option")
                    opt.value = index;
                    opt.innerText = option;

                    if (mode === MODE_PREVIEW) {
                        opt.innerText = `[${index}] ${option}`;
                    }

                    return opt;
                })

                input.append(...options);

                return input;
            },
            "boolean": () => {
                let input = document.createElement("select");
                input.name = element.id;
                input.id = element.id;

                let options = element.options.map((option, index) => {
                    let opt = document.createElement("option")
                    opt.value = index == 0;
                    opt.innerText = option;

                    return opt;
                })

                input.append(...options);

                return input;
            },
            "radio": () => {
                let input = document.createElement("div");
                input.classList.add("radio", element.alignment ? "alignment-" + element.alignment : "alignment-vertical")

                let options = element.options.map((option, index) => {
                    let container = document.createElement("div");

                    let label = document.createElement("label");

                    let radio = document.createElement("input");
                    radio.type = "radio";
                    radio.value = index;
                    radio.name = element.id;
                    radio.classList.add("type-radio");

                    if (mode === MODE_PREVIEW) {
                        option = `[${index}] ${option}`;
                    }

                    label.append(radio, option);

                    if (element.id in result && result[element.id] == index) {
                        radio.checked = true;
                    }

                    return label;
                })

                input.append(...options);

                return input;
            },
            "checkbox": () => {
                let input = document.createElement("div");

                let options = element.options.map((option, index) => {
                    let container = document.createElement("div");

                    let label = document.createElement("label");

                    let checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.id = element.id + String.fromCharCode(index + 97);
                    checkbox.classList.add("type-checkbox");

                    if (mode === MODE_PREVIEW) {
                        option = `[${checkbox.id}] ${option}`;
                    }

                    label.append(checkbox, option);

                    // Last option exclusive
                    if (element.last_option_exclusive) {
                        // Uncheck others if the last one is checked
                        if (index === element.options.length - 1) {
                            checkbox.addEventListener("change", e => {
                                if (e.target.checked) {
                                    element.options.forEach((option, index) => {
                                        if (index !== element.options.length - 1) {
                                            let id = element.id + String.fromCharCode(index + 97);
                                            document.getElementById(id).checked = false;
                                            result[id] = false;
                                        }
                                    })

                                }
                            })
                        } else {
                            // Uncheck last one if one of the others is checked
                            checkbox.addEventListener("change", e => {
                                if (e.target.checked) {
                                    let id = element.id + String.fromCharCode(options.length - 1 + 97);
                                    document.getElementById(id).checked = false;
                                    result[id] = false;
                                }
                            })
                        }
                    }

                    if (checkbox.id in result && result[checkbox.id] === true) {
                        checkbox.checked = true;
                    }

                    return label;
                })

                input.append(...options);

                return input;
            }
        }

        if (element.type in creator) {
            let domElement = creator[element.type]();

            domElement.classList.add("type-" + element.type);

            if (element.id) {
                domElement.id = element.id;
            }

            domElement.pattern = element.check;


            if (filterTriggers.includes(element.id)) {
                domElement.addEventListener('input', update);
            }


            if (element.id in result) {
                domElement.value = result[element.id];
            }

            let fragment = document.createElement("div");

            if (element.title) {
                let title = document.createElement("p");
                title.innerText = element.title;

                title.classList.add(element.id, "title");
                fragment.appendChild(title);

                if (mode === MODE_PREVIEW) {
                    title.innerText = `[${element.id}] ${title.innerText}`;
                }
            }


            domElement.classList.add(element.id);

            if (mode === MODE_PREVIEW && element.condition) {
                let previewCondition = document.createElement("p");
                previewCondition.innerHTML = `[ <i>Condition:</i>  <code>${element.condition}</code> ]`;
                fragment.appendChild(previewCondition);
            }

            fragment.appendChild(domElement);

            fragment.title = element.tooltip || "";
            fragment.addEventListener("click", e => showInfo(e, element));

            return fragment;
        } else return "";
    }

    const createForm = (form) => {
        let formElement = document.createElement("form");

        let domElements = form.elements.map(elem => createInput(elem));

        let title = document.createElement("h2");
        title.innerText = form.title;

        if (mode === MODE_PREVIEW) {
            title.innerText = "[Preview] " + title.innerText;
        }

        formElement.append(title, ...domElements);

        formElement.addEventListener('change', update);

        return formElement;
    }

    const handleTabClick = e => {
        currentTab = parseInt(e.target.getAttribute("data-index"));
        result = results[currentTab];
        updateTabs();
    }

    const updateTabs = () => {
        tabs.forEach(t => {
            if (parseInt(t.getAttribute("data-index")) === currentTab) {
                t.classList.add("selected");

                if (currentTab !== preTab) {
                    filterTriggers = formTypes[result.type].elements
                        .filter(element => element.condition)
                        .map(element => element.condition.match(/\$\w*/g))
                        .flat()
                        .map(ids => ids.replaceAll('$', ''));

                    const formView = document.getElementById("formview");
                    formView.innerHTML = "";
                    formView.appendChild(createForm(formTypes[result.type]));

                    applyFilters();
                    updateInfo();

                    preTab = currentTab;
                }

            } else {
                t.classList.remove("selected");
            }
        })
    }

    const createTab = (result, index) => {
        let tab = document.createElement("div");
        tab.classList.add("tab");

        let content = document.createElement("span");
        tab.appendChild(content);

        tab.setAttribute("data-index", index);

        tab.addEventListener("click", handleTabClick);

        tabs.push(tab);
        return tab;
    }

    const score = r => {
        const scoring = formTypes[r.type].scoring;

        let maxScore = 0;
        let reachedScore = 0;

        for (indicator in scoring) {
            if (scoring[indicator].not_applicable && evaluateCondition(scoring[indicator].not_applicable)) {
                continue;
            }

            maxScore += scoring[indicator].max;

            switch (scoring[indicator].op) {
                case "sum":
                    reachedScore += scoring[indicator].points
                        .filter(p => evaluateCondition(p.condition))
                        .reduce((sum, next) => sum + next.value, 0);
                    break;
                case "select":
                    reachedScore += (scoring[indicator].points.find(p => evaluateCondition(p.condition)) || { value: 0 }).value;
                    break;
                default:
                    break;
            }


        }


        return {
            max: maxScore,
            score: reachedScore,
            relative: reachedScore / maxScore,
            percentage: ((reachedScore / maxScore) * 100).toFixed(1)
        }
    }

    let meta, pub, software, data, max;

    let filterTriggers;

    const params = new URLSearchParams(window.location.search);
    const mode = params.get("mode");

    let results = getSavedData();

    let currentTab = 0;
    let preTab = -1;
    let result = results[currentTab];

    let prefixes = {
        meta: "M",
        pub: "P",
        software: "S",
        data: "D"
    }

    menu().then(m => {
        formTypes = m;
        ({ meta, pub, software, data, max } = m);
        results.forEach((r, index) => {
            document.getElementById("tabs").appendChild(createTab(r, index));
        });

        updateTabs();
        updateInfo();
        applyFilters();
    })
</script>

</html>