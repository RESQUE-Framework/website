<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RESQUE</title>
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <div id="main">
        <div class="tabs-sidebar">
            <div class="sidebar-top">
                <div class="top">
                    <h3>RESQUE</h3>
                    <div id="actions">
                        <button onclick="reset()">Reset</button>
                        <button onclick="triggerLoad()">Load</button>
                        <button onclick="exp()">Export</button>
                    </div>
                </div>
                <p id="slot-info"></p>
            </div>
            <div class="tabs-container">
                <div id="tabs">

                </div>
            </div>
            <div id="add-container">
                <div class="doi-input">
                    <button onclick="document.getElementById('add-pdf').click()">Extract DOI from PDF</button>
                    <input id="add-doi" type="text" placeholder="DOI (optional)" />
                </div>

                <div>
                    <b>Add</b>
                    <button onclick="newTab('pub')">Publication</button>
                    <button onclick="newTab('software')">Software</button>
                    <button onclick="newTab('data')">Data Set</button>
                </div>
            </div>
        </div>
        <div id="formview"></div>
        <div id="menu">
            <div class="card" id="score-box">
                <div class="top">
                    <h3>Score</h3>
                </div>
                <div id="score-container">
                    <p id="score-percentage"></p>
                    <p id="score-dot">â€¢</p>
                    <p id="score-minmax"></p>
                </div>
                <p id="no-score">No score - applicant requests manual processing</p>
            </div>
            <div class="card">
                <p id="item-info">Click on an indicator to see detailed information</p>
                <details id="item-background-details">
                    <summary>Background information</summary>
                    <span id="item-background"></span>
                </details>
            </div>
            <div class="menu-bottom">
                <a class="github-link" href="https://github.com/nicebread/RESQUE">GitHub</a>
            </div>
        </div>
    </div>
    </div>
    <div id="add-modal" class="modal">

        <!-- Modal content -->
        <div class="modal-content">

        </div>

    </div>
    <input id="fileInput" type="file" accept="text/json" style="visibility: hidden" onchange="handleLoad(this.files)" />
    <a id="download" style="visibility: hidden"></a>
    <input id="add-pdf" type="file" accept="application/pdf" onchange="handleSelectPDF(this.files)"
        style="visibility: hidden;" />


    <script src="https://mozilla.github.io/pdf.js/build/pdf.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            'https://mozilla.github.io/pdf.js/build/pdf.worker.js';

        function extractText(pdf) {
            var totalPageCount = pdf.numPages;
            var countPromises = [];
            for (
                var currentPage = 1;
                currentPage <= totalPageCount;
                currentPage++
            ) {
                var page = pdf.getPage(currentPage);
                countPromises.push(
                    page.then(function (page) {
                        var textContent = page.getTextContent();
                        return textContent.then(function (text) {
                            return text.items
                                .map(function (s) {
                                    return s.str;
                                })
                                .join(' ');
                        });
                    }),
                );
            }

            return Promise.all(countPromises).then(function (texts) {
                return texts.join(' ');
            })
        }

        function handleSelectPDF(files) {
            var file = files[0];

            //Step 2: Read the file using file reader
            var fileReader = new FileReader();

            fileReader.onload = function () {

                //Step 4:turn array buffer into typed array
                var typedarray = new Uint8Array(this.result);

                //Step 5:pdfjs should be able to read this
                const loadingTask = pdfjsLib.getDocument(typedarray);
                loadingTask.promise.then(pdf => {
                    extractText(pdf).then(text => {
                        let dois = extractDOIs(text);
                        document.getElementById('add-doi').value = dois[0];

                        if (mode === MODE_PREVIEW) {
                            console.log(text);
                            console.log(dois);
                        }
                    })
                });
            };
            //Step 3:Read the file as ArrayBuffer
            fileReader.readAsArrayBuffer(file);
        }

        function extractDOIs(text) {
            let pattern = /\b10\.\d{4,9}\/[-._;()/:a-zA-Z0-9]+\b/g;
            const dois = text.match(pattern);

            return [...new Set(dois)];
        }
    </script>

    <script>


        async function use(...packs) {

            const pool = [];

            const ps = await Promise.all(packs.map(async pack => {
                const response = await fetch("../packs/" + pack + ".json");
                return response.json();
            }));

            ps.forEach(p => pool.push(...p.elements));

            let versions = {};

            ps.forEach(pack => versions[pack.prefix] = pack.version);

            let scoringInfos = {}

            ps.forEach(pack => scoringInfos = { ...scoringInfos, ...pack.scoring })

            return {
                title: ps[0].title,
                versions,
                scoring: scoringInfos,
                pool
            };
        }

        function pick(combinedPack, ...ids) {
            return {
                title: combinedPack.title,
                versions: combinedPack.versions,
                scoring: combinedPack.scoring,
                elements: ids.length <= 0 ? combinedPack.pool : ids.map(id => combinedPack.pool.find(item => item.id === id))
            };
        }

        function pickByPrefix(combinedPack, prefix) {
            return {
                title: combinedPack.title,
                versions: combinedPack.versions,
                scoring: combinedPack.scoring,
                elements: combinedPack.pool.filter(item => item.id.startsWith(prefix))
            };
        }

        function pickByCondition(combinedPack, condition) {
            return {
                title: combinedPack.title,
                scoring: combinedPack.scoring,
                elements: combinedPack.pool.filter(item => condition(item))
            };
        }

        function pickExclude(combinedPack, ...ids) {
            return pickByCondition(combinedPack, item => !ids.includes(item.id));
        }
    </script>

    <script src="menu.js"></script>

    <script>
        const MODE_PREVIEW = "preview";

        let elems = [];
        let tabs = [];

        let formTypes;

        const getVersion = type => formTypes[type].versions[prefixes[type]];

        const getDefaultValues = type => {
            let defaultValues = {};

            for (element of formTypes[type].elements) {
                if (element.default) {
                    defaultValues[element.id] = element.default;
                }
            }

            return defaultValues;
        }

        // Modal

        window.onclick = e => {
            if (event.target.classList.contains("modal")) {
                e.target.style.display = "none";
            }
        }

        const openAddModal = () => {
            if (doimagic === "active") {
                document.getElementById("add-modal").style.display = "block";
            } else {
                newTab("pub");
            }
        }

        const closeAddModal = () => {
            document.getElementById("add-modal").style.display = "none";
        }

        const newTab = type => {
            let doiField = document.getElementById("add-doi");
            let doi = doiField.value;

            doiField.value = "";

            let index = results.length

            results.push({
                type,
                version: getVersion(type),
                created: Date.now(),
                ...getDefaultValues(type)
            });

            document.getElementById("tabs").appendChild(createTab(results[results.length - 1], results.length - 1));

            closeAddModal();

            if (doi) {
                fetch("https://doi.org/" + doi.trim(), {
                    headers: {
                        Accept: 'application/vnd.citationstyles.csl+json'
                    }
                })
                    .then(response => response.json())
                    .then(response => {
                        if (mode === MODE_PREVIEW) {
                            console.log(response);
                        }

                        if (type === "pub") {
                            results[index].P3 = response.title;
                            results[index].P4 = response.published["date-parts"][0][0];
                            results[index].P5 = response.DOI;

                            save();

                            if (currentTab === index) {
                                location.reload();
                            } else {
                                // Switch to new tab
                                tabs[results.length - 1].click();

                                tabsElement.scrollTo({
                                    top: tabsElement.scrollHeight,
                                    behavior: "smooth"
                                });
                            }
                        }
                    })
            } else {
                // Switch to new tab
                save();

                tabs[results.length - 1].click();

                tabsElement.scrollTo({
                    top: tabsElement.scrollHeight,
                    behavior: "smooth"
                });
            }

            const tabsElement = document.getElementsByClassName("tabs-sidebar")[0];
        }

        const save = () => {
            localStorage.setItem("formdata", JSON.stringify(results))
        }

        const getSavedData = () => {
            return JSON.parse(localStorage.getItem("formdata")) || [{ type: "meta" }];
        }

        const reset = () => {
            results = {};
            localStorage.clear();
            sessionStorage.clear();
            location.reload();
        }

        const triggerLoad = () => {
            fileSelector = document.getElementById("fileInput");
            fileSelector.click();
        }

        const handleLoad = async files => {
            let loadedData = JSON.parse(await files[0].text());

            if (loadedData.every(r => getVersion(r.type) === r.version)) {
                results = loadedData;
                save();
                sessionStorage.clear();
                location.reload();
            } else {
                alert("Error: Could not load data because it was created using an earlier version.");
            }
        }

        const exp = () => {
            let millis = Date.now();
            results[0].exported = millis;
            let json = JSON.stringify(results, null, 2);
            let blob = new Blob([json], { type: "text/json;charset=utf-8" });
            let filename = `resque_${results[0].M1 ? results[0].M1.toLowerCase() + "_" : ""}${millis}.json`;

            let a = document.getElementById("download");
            a.innerText = filename;
            a.download = filename;
            a.href = (window.URL || window.webkitURL).createObjectURL(blob);

            a.click();
        }

        const update = e => {

            if (e.type !== 'click') {
                // Save date_created
                if (!results[0].date_created) {
                    results[0].date_created = Date.now();

                    if (mode === MODE_PREVIEW) {
                        console.log("First change: date_created saved.");
                    }
                }

                results[0].date_modified = Date.now();
            }

            if (e.target.classList.contains("type-radio") || e.target.classList.contains("type-dropdown")) {
                result[e.target.name] = parseInt(e.target.value);
            } else if (e.target.classList.contains("type-checkbox")) {
                result[e.target.id] = e.target.checked;
            } else if (e.target.classList.contains("type-boolean")) {
                result[e.target.id] = e.target.value === "true";
            } else if (e.target.classList.contains("type-textbox")) {
                result[e.target.id] = e.target.innerText;
            } else {
                result[e.target.id] = e.target.value;
            }

            if (mode === MODE_PREVIEW) {
                console.log(results);
            }

            save();
            updateInfo();
            updateTabs();
            applyFilters();

            // Prevent reload on click events
            // update is only triggered by click events to show correct info on the right
            // it is not relevant for results/displaying data 
            if (formTypes[result.type].elements.some(elem => elem.type === 'info' && /\$[a-zA-Z0-9_]+/.test(elem.text)) && e.type !== 'click') {
                loadForm({ index: currentTab, preserveScrollHeight: true });
            }
        }

        const updateInfo = () => {
            const usedSlots = results.length - 1;
            const maxReached = usedSlots >= max;

            document.getElementById("slot-info").innerText = `${usedSlots} of ${max} slots used${maxReached ? ", you can't add more publications." : ""}`;

            if (usedSlots >= max) {
                document.getElementById("add-container").style.display = "none"
            } else {
                document.getElementById("add-container").style.display = "inherit"
            }

            let numberOfPublications = 0;
            let numberOfSoftwareProjects = 0;
            let numberOfDataSets = 0;

            tabs.forEach(t => {
                const content = t.firstChild;

                const index = parseInt(t.getAttribute("data-index"));
                const result = results[index];

                switch (result.type) {
                    case "meta":
                        content.innerHTML = `<b>Author</b>${result["M1"] ? '<br>' + result["M1"] : ''}`;
                        break;
                    case "pub":
                        content.innerHTML = `<b>Publication ${++numberOfPublications}</b>${result["P3"] ? '<br>' + result["P3"] : ''}`
                        break;
                    case "software":
                        content.innerHTML = `<b>Software Project ${++numberOfSoftwareProjects}</b>${result["S3"] ? '<br>' + result["S3"] : ''}`;
                        break;
                    case "data":
                        content.innerHTML = `<b>Data Set ${++numberOfDataSets}</b>${result["D3"] ? '<br>' + result["D3"] : ''}`;
                        break;

                    default:
                        break;
                }
            })

            if (result.type === 'meta') {
                // Hide the score box and skip updating score values
                document.getElementById('score-box').style.display = "none";
                return;
            }

            let scoringResult = score(result);

            // Show score box
            document.getElementById('score-box').style.display = "";

            if (scoringResult.max > 0) {
                document.getElementById("no-score").style.display = "none";
                document.getElementById("score-container").style.display = "flex"
                document.getElementById("score-minmax").innerHTML = `${scoringResult.score} / ${scoringResult.max}`
                document.getElementById("score-percentage").innerHTML = `${scoringResult.percentage}%`
            } else {
                document.getElementById("no-score").style.display = "block";
                document.getElementById("score-container").style.display = "none"
            }
        }

        const preprocessCondition = condition => {
            let processedCondition = condition
                .replaceAll(/([\$\w]+)\s*=\|=\s*\[(.*?)\]/g, (match, variable, list) => {
                    return "(" + list.split(",")
                        .map(value => `${variable} === ${value.trim()}`)
                        .join(" || ") + ")";
                })
                .replaceAll(/([\$\w]+)\s*=&=\s*\[(.*?)\]/g, (match, variable, list) => {
                    return "(" + list.split(",")
                        .map(value => `${variable} === ${value.trim()}`)
                        .join(" && ") + ")";
                })

            return processedCondition;
        }

        const insertValuesIntoCondition = condition => {
            return condition.replaceAll(/\$(\w*)/g, `result['$1']`);
        }

        const evaluateCondition = condition => eval(insertValuesIntoCondition(preprocessCondition(condition)));

        const applyFilters = () => {
            if (mode === MODE_PREVIEW) {
                return;
            }

            for (let elem of elems) {
                if (!elem.condition) continue;


                const domElements = [...document.getElementsByClassName(elem.id)];

                if (evaluateCondition(elem.condition)) {
                    domElements.forEach(de => de.style.display = "")
                } else {
                    domElements.forEach(de => de.style.display = "none")
                }
            }
        }

        const countWords = (text) => {
            return text.trim() ? text.replace(/[\r\n\t]+/g, " ").split(/\s+/).filter(x => x).length : 0;
        }

        const updateWordcount = (textbox, wordcount) => {
            const words = countWords(textbox.innerText);

            if (textbox.hasAttribute("data-maxwords")) {
                const maxwords = parseInt(textbox.getAttribute("data-maxwords"));
                wordcount.innerText = words + " / " + maxwords;

                if (words <= maxwords) {
                    wordcount.classList.add("wordcount-ok");
                    wordcount.classList.remove("wordcount-warning");
                } else {
                    wordcount.classList.remove("wordcount-ok");
                    wordcount.classList.add("wordcount-warning");
                }
            } else {
                wordcount.innerText = words;
            }
        }

        const textboxWordcount = e => {
            const wordcount = document.getElementById(e.target.id + "-wordcount");

            updateWordcount(e.target, wordcount);
        }

        const partialHighlight = (indicatorId, text) => {
            return text.replaceAll(/\{(.*?)\|(.*?)\}/g, (match, foundCondition, text) => {
                let condition = foundCondition.trim();

                if (condition.startsWith(':')) {
                    condition = `$${indicatorId} =|= [${condition.replace(':', '')}]`
                }

                return evaluateCondition(condition)
                    ? `<span class="highlight">${text.trim()}</span>`
                    : text
            });
        }

        const showInfo = (e, element) => {
            const itemInfo = document.getElementById("item-info");
            const itemBackground = document.getElementById("item-background");
            const itemBackgroundDetails = document.getElementById("item-background-details");

            if (element.info) {
                itemInfo.style.color = "#333333";
                itemInfo.innerHTML = `<b>${element.id}</b>${element.eval_dimension ? '<span id="eval-dimension">' + element.eval_dimension + '</span>' : ""}<br><br>${partialHighlight(element.id, element.info)}`;
            } else {
                itemInfo.style.color = "gray";
                itemInfo.innerHTML = `<b>${element.id}</b>${element.eval_dimension ? '<span id="eval-dimension">' + element.eval_dimension + '</span>' : ""}<br><br><i>No information</i>`;
            }

            if (element.background) {
                itemBackground.innerHTML = element.background;
                itemBackgroundDetails.style.display = "block";
                itemBackgroundDetails.removeAttribute("open");
            } else {
                itemBackgroundDetails.style.display = "none";
            }
        }

        const insertValuesIntoText = text => {
            return text
                .replaceAll(/\$([a-zA-Z0-9_]+)@([a-zA-Z0-9_]+)/g, (match, variable, type) => {
                    switch (type.trim()) {
                        case 'datetime': {
                            const millis = parseInt(result[variable.trim()]);
                            return millis ? new Date(millis).toLocaleString() : '...';
                        }
                        case 'date': {
                            const millis = parseInt(result[variable.trim()]);
                            return millis ? new Date(millis).toLocaleDateString() : '...';
                        }
                    }
                })
                .replaceAll(/\$([a-zA-Z0-9_]+)/g, (match, variable) => {
                    return result[variable.trim()];
                });
        }

        const preprocessText = text => insertValuesIntoText(partialHighlight(null, text));

        const createInput = (element) => {
            elems.push(element);

            const creator = {
                "separator": () => {
                    let separator = document.createElement("hr");

                    return separator;
                },
                "info": () => {
                    let info = document.createElement("p");
                    info.id = element.id;

                    info.innerHTML = preprocessText(element.text);

                    return info;
                },
                "text": () => {
                    let input = document.createElement("input");
                    input.type = "text";

                    input.placeholder = element.title || '';

                    return input;
                },
                "textbox": () => {
                    let container = document.createElement("div");
                    container.classList.add("textbox-container");

                    let input = document.createElement("div");
                    input.id = element.id;
                    input.classList.add("textbox", "type-textbox");
                    input.contentEditable = true;

                    let wordcount = document.createElement("div");
                    wordcount.id = element.id + "-wordcount";
                    wordcount.classList.add("wordcount");

                    if (element.id in result) {
                        input.innerText = result[element.id];
                    }

                    if (element.maxwords) {
                        input.setAttribute("data-maxwords", element.maxwords);
                        wordcount.classList.add("wordcount-max");
                    }

                    updateWordcount(input, wordcount);

                    input.addEventListener("input", textboxWordcount);
                    input.addEventListener("blur", update);

                    container.append(input, wordcount);

                    return container;
                },
                "number": () => {
                    let input = document.createElement("input");
                    input.type = "number";

                    input.placeholder = element.title || '';

                    return input;
                },
                "date": () => {
                    let input = document.createElement("input");
                    input.type = "date";

                    input.placeholder = element.title || '';

                    return input;
                },
                "dropdown": () => {
                    let input = document.createElement("select");
                    input.name = element.id;
                    input.id = element.id;

                    const values = element.values || element.options;

                    let options = element.options.map((option, index) => {
                        let opt = document.createElement("option")
                        opt.value = index;
                        opt.innerText = option;

                        if (mode === MODE_PREVIEW) {
                            opt.innerText = `[${index}] ${option}`;
                        }

                        return opt;
                    })

                    input.append(...options);

                    return input;
                },
                "boolean": () => {
                    let input = document.createElement("select");
                    input.name = element.id;
                    input.id = element.id;

                    let options = element.options.map((option, index) => {
                        let opt = document.createElement("option")
                        opt.value = index == 0;
                        opt.innerText = option;

                        return opt;
                    })

                    input.append(...options);

                    return input;
                },
                "radio": () => {
                    let input = document.createElement("div");
                    input.classList.add("radio", element.alignment ? "alignment-" + element.alignment : "alignment-vertical")

                    let options = element.options.map((option, index) => {
                        let container = document.createElement("div");

                        let label = document.createElement("label");

                        let radio = document.createElement("input");
                        radio.type = "radio";
                        radio.value = index;
                        radio.name = element.id;
                        radio.classList.add("type-radio");

                        if (mode === MODE_PREVIEW) {
                            option = `[${index}] ${option}`;
                        }

                        label.append(radio, option);

                        if (element.id in result && result[element.id] == index) {
                            radio.checked = true;
                        }

                        return label;
                    })

                    input.append(...options);

                    return input;
                },
                "checkbox": () => {
                    let input = document.createElement("div");

                    let options = element.options.map((option, index) => {
                        let container = document.createElement("div");

                        let label = document.createElement("label");

                        let checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.id = element.id + String.fromCharCode(index + 97);
                        checkbox.classList.add("type-checkbox");

                        if (mode === MODE_PREVIEW) {
                            option = `[${checkbox.id}] ${option}`;
                        }

                        label.append(checkbox, option);

                        // Last option exclusive
                        if (element.last_option_exclusive) {
                            // Uncheck others if the last one is checked
                            if (index === element.options.length - 1) {
                                checkbox.addEventListener("change", e => {
                                    if (e.target.checked) {
                                        element.options.forEach((option, index) => {
                                            if (index !== element.options.length - 1) {
                                                let id = element.id + String.fromCharCode(index + 97);
                                                document.getElementById(id).checked = false;
                                                update({ ...e, target: document.getElementById(id) })
                                            }
                                        })
                                    }
                                })
                            } else {
                                // Uncheck last one if one of the others is checked
                                checkbox.addEventListener("change", e => {
                                    let id = element.id + String.fromCharCode(options.length - 1 + 97);

                                    if (e.target.checked) {
                                        document.getElementById(id).checked = false;
                                    }

                                    update({ ...e, target: document.getElementById(id) });
                                })
                            }
                        }

                        if (checkbox.id in result && result[checkbox.id] === true) {
                            checkbox.checked = true;
                        }

                        return label;
                    })

                    input.append(...options);

                    return input;
                }
            }

            if (element.type in creator) {
                let domElement = creator[element.type]();

                domElement.classList.add("type-" + element.type);

                if (element.id) {
                    domElement.id = element.id;
                }

                domElement.pattern = element.check;


                if (filterTriggers.includes(element.id)) {
                    domElement.addEventListener('input', update);
                }


                if (element.id in result) {
                    domElement.value = result[element.id];
                }

                let fragment = document.createElement("div");

                if (element.title) {
                    let title = document.createElement("p");
                    title.innerText = element.title;

                    title.classList.add(element.id, "title");
                    fragment.appendChild(title);

                    if (mode === MODE_PREVIEW) {
                        title.innerText = `[${element.id}] ${title.innerText}`;
                    }
                }


                domElement.classList.add(element.id);

                if (mode === MODE_PREVIEW && element.condition) {
                    let previewCondition = document.createElement("p");
                    previewCondition.innerHTML = `[ <i>Condition:</i>  <code>${element.condition}</code> ]`;
                    fragment.appendChild(previewCondition);
                }

                fragment.appendChild(domElement);

                fragment.title = element.tooltip || "";
                fragment.addEventListener("click", update);
                fragment.addEventListener("click", e => showInfo(e, element));

                return fragment;
            } else return "";
        }

        const createForm = (form) => {
            let formElement = document.createElement("form");

            let domElements = form.elements.map(elem => createInput(elem));

            let title = document.createElement("h2");
            title.innerText = form.title;

            if (mode === MODE_PREVIEW) {
                title.innerText = "[Preview] " + title.innerText;
            }

            formElement.append(title, ...domElements);

            formElement.addEventListener('change', update);

            return formElement;
        }

        const handleTabClick = e => {
            currentTab = parseInt(e.target.getAttribute("data-index"));
            sessionStorage.setItem("index", currentTab.toString())

            if (currentTab !== preTab) {
                loadForm({ index: currentTab });
                preTab = currentTab;
            }

            updateTabs();
        }

        const loadForm = options => {
            console.log(options)
            result = results[options.index];

            const formView = document.getElementById("formview");
            const scrollPre = formView.scrollTop;

            filterTriggers = formTypes[result.type].elements
                .filter(element => element.condition)
                .map(element => element.condition.match(/\$\w*/g))
                .flat()
                .map(ids => ids.replaceAll('$', ''));

            formView.innerHTML = "";
            formView.appendChild(createForm(formTypes[result.type]));

            if (options.preserveScrollHeight) {
                formView.scrollHeight = scrollPre;
            }

            applyFilters();
            updateInfo();
        }

        const updateTabs = () => {
            tabs.forEach(t => {
                if (parseInt(t.getAttribute("data-index")) === currentTab) {
                    t.classList.add("selected");
                } else {
                    t.classList.remove("selected");
                }
            })
        }

        const createTab = (result, index) => {
            let tab = document.createElement("div");
            tab.classList.add("tab");

            let content = document.createElement("span");
            tab.appendChild(content);

            tab.setAttribute("data-index", index);

            tab.addEventListener("click", handleTabClick);

            tabs.push(tab);
            return tab;
        }

        const score = r => {
            const scoring = formTypes[r.type].scoring;

            let maxScore = 0;
            let reachedScore = 0;

            for (indicator in scoring) {
                if (scoring[indicator].not_applicable && evaluateCondition(scoring[indicator].not_applicable)) {
                    continue;
                }

                maxScore += scoring[indicator].max;

                switch (scoring[indicator].op) {
                    case "sum":
                        reachedScore += scoring[indicator].points
                            .filter(p => evaluateCondition(p.condition))
                            .reduce((sum, next) => sum + next.value, 0);
                        break;
                    case "select":
                        reachedScore += (scoring[indicator].points.find(p => evaluateCondition(p.condition)) || { value: 0 }).value;
                        break;
                    default:
                        break;
                }


            }


            return {
                max: maxScore,
                score: reachedScore,
                relative: reachedScore / maxScore,
                percentage: ((reachedScore / maxScore) * 100).toFixed(1)
            }
        }

        let meta, pub, software, data, max;

        let filterTriggers;

        const params = new URLSearchParams(window.location.search);
        const mode = params.get("mode");
        const doimagic = params.get("doimagic");

        let results = getSavedData();

        let currentTab = parseInt(sessionStorage.getItem("index") || "0");
        let preTab = -1;
        let result = results[currentTab];

        let prefixes = {
            meta: "M",
            pub: "P",
            software: "S",
            data: "D"
        }

        menu().then(m => {
            formTypes = m;
            ({ meta, pub, software, data, max } = m);
            results.forEach((r, index) => {
                document.getElementById("tabs").appendChild(createTab(r, index));
            });

            loadForm({ index: currentTab });
            updateTabs();
            updateInfo();
            applyFilters();
        })
    </script>
</body>

</html>